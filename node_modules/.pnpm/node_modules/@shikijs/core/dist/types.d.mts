import { x as ThemeRegistrationAny, r as ThemeRegistrationResolved, c as IGrammar, L as LanguageInput, T as ThemeInput, C as CodeToHastOptions, G as ResolveBundleKey, h as Root, i as CodeToTokensOptions, j as TokensResult, l as CodeToTokensBaseOptions, m as ThemedToken, n as CodeToTokensWithThemesOptions, o as ThemedTokenWithVariants, p as SpecialTheme, D as SpecialLanguage, J as LanguageRegistration } from './chunk-tokens.mjs';
export { A as AnsiLanguage, aa as Awaitable, B as BundledHighlighterOptions, K as BundledLanguageInfo, a0 as BundledThemeInfo, X as CodeOptionsMeta, U as CodeOptionsMultipleThemes, Q as CodeOptionsSingleTheme, V as CodeOptionsThemes, W as CodeToHastOptionsCommon, u as CodeToHastRenderOptions, Y as CodeToHastRenderOptionsCommon, af as DecorationItem, ae as DecorationOptions, O as DynamicImportLanguageRegistration, $ as DynamicImportThemeRegistration, F as FontStyle, H as HighlighterCoreOptions, b as IRawGrammar, M as MaybeArray, ab as MaybeGetter, ac as MaybeModule, ah as Offset, ai as OffsetOrPosition, z as PlainTextLanguage, P as Position, b as RawGrammar, a as RawTheme, g as RawThemeSetting, k as RequireKeys, ag as ResolvedDecorationItem, aj as ResolvedPosition, y as ShikiTransformer, a6 as ShikiTransformerContext, t as ShikiTransformerContextCommon, a5 as ShikiTransformerContextMeta, v as ShikiTransformerContextSource, a7 as ShikijiTransformer, a8 as ShikijiTransformerContext, a9 as ShikijiTransformerContextCommon, ad as StringLiteralUnion, _ as ThemeRegistration, Z as ThemeRegistrationRaw, a2 as ThemedTokenExplanation, a1 as ThemedTokenScopeExplanation, a3 as TokenBase, q as TokenStyles, s as TokenizeWithThemeOptions, a4 as TransformerOptions } from './chunk-tokens.mjs';
import './chunk-index.mjs';

interface ShikiInternal {
    setTheme(name: string | ThemeRegistrationAny): {
        theme: ThemeRegistrationResolved;
        colorMap: string[];
    };
    getTheme(name: string | ThemeRegistrationAny): ThemeRegistrationResolved;
    getLangGrammar(name: string): IGrammar;
    getLoadedThemes(): string[];
    getLoadedLanguages(): string[];
    loadLanguage(...langs: LanguageInput[]): Promise<void>;
    loadTheme(...themes: ThemeInput[]): Promise<void>;
    getAlias(): Record<string, string>;
    updateAlias(alias: Record<string, string>): void;
}
/**
 * Generic instance interface of Shiki
 */
interface HighlighterGeneric<BundledLangKeys extends string, BundledThemeKeys extends string> {
    /**
     * Get highlighted code in HTML string
     */
    codeToHtml(code: string, options: CodeToHastOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>): string;
    /**
     * Get highlighted code in HAST.
     * @see https://github.com/syntax-tree/hast
     */
    codeToHast(code: string, options: CodeToHastOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>): Root;
    /**
     * Get highlighted code in tokens. Uses `codeToTokensWithThemes` or `codeToTokensBase` based on the options.
     */
    codeToTokens(code: string, options: CodeToTokensOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>): TokensResult;
    /**
     * Get highlighted code in tokens with a single theme.
     * @returns A 2D array of tokens, first dimension is lines, second dimension is tokens in a line.
     */
    codeToTokensBase(code: string, options: CodeToTokensBaseOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>): ThemedToken[][];
    /**
     * Get highlighted code in tokens with multiple themes.
     *
     * Different from `codeToTokensBase`, each token will have a `variants` property consisting of an object of color name to token styles.
     *
     * @returns A 2D array of tokens, first dimension is lines, second dimension is tokens in a line.
     */
    codeToTokensWithThemes(code: string, options: CodeToTokensWithThemesOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>): ThemedTokenWithVariants[][];
    /**
     * @deprecated Renamed to `codeToTokensBase`, or use high-level `codeToTokens` directly.
     */
    codeToThemedTokens(code: string, options: CodeToTokensBaseOptions<ResolveBundleKey<BundledLangKeys>, ResolveBundleKey<BundledThemeKeys>>): ThemedToken[][];
    /**
     * Load a theme to the highlighter, so later it can be used synchronously.
     */
    loadTheme(...themes: (ThemeInput | BundledThemeKeys | SpecialTheme)[]): Promise<void>;
    /**
     * Load a language to the highlighter, so later it can be used synchronously.
     */
    loadLanguage(...langs: (LanguageInput | BundledLangKeys | SpecialLanguage)[]): Promise<void>;
    /**
     * Get the registered theme object
     */
    getTheme(name: string | ThemeRegistrationAny): ThemeRegistrationResolved;
    /**
     * Get the registered language object
     */
    getLangGrammar(name: string | LanguageRegistration): IGrammar;
    /**
     * Set the current theme and get the resolved theme object and color map.
     * @internal
     */
    setTheme: ShikiInternal['setTheme'];
    /**
     * Get the names of loaded languages
     *
     * Special-handled languages like `text`, `plain` and `ansi` are not included.
     */
    getLoadedLanguages(): string[];
    /**
     * Get the names of loaded themes
     *
     * Special-handled themes like `none` are not included.
     */
    getLoadedThemes(): string[];
    /**
     * Get internal context object
     * @internal
     * @deprecated
     */
    getInternalContext(): ShikiInternal;
}

export { CodeToHastOptions, CodeToTokensBaseOptions, CodeToTokensOptions, CodeToTokensWithThemesOptions, IGrammar as Grammar, type HighlighterGeneric, IGrammar, LanguageInput, LanguageRegistration, ResolveBundleKey, type ShikiInternal, SpecialLanguage, SpecialTheme, ThemeInput, ThemeRegistrationAny, ThemeRegistrationResolved, ThemedToken, ThemedTokenWithVariants, TokensResult };
